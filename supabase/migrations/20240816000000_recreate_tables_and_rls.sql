-- 1. Limpeza Completa (Drop em ordem de dependência reversa)
-- Remove triggers e funções primeiro para evitar erros de dependência
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user;

DROP TRIGGER IF EXISTS set_workspace_owner_trigger ON public.workspaces;
DROP FUNCTION IF EXISTS public.set_workspace_owner;

DROP TRIGGER IF EXISTS add_creator_to_workspace_trigger ON public.workspaces;
DROP FUNCTION IF EXISTS public.add_creator_to_workspace;

-- Remove tabelas na ordem correta para satisfazer as restrições de chave estrangeira
DROP TABLE IF EXISTS public.messages;
DROP TABLE IF EXISTS public.chats;
DROP TABLE IF EXISTS public.contacts;
DROP TABLE IF EXISTS public.evolution_api_instances;
DROP TABLE IF EXISTS public.evolution_api_configs;
DROP TABLE IF EXISTS public.user_workspaces;
DROP TABLE IF EXISTS public.users;
DROP TABLE IF EXISTS public.workspaces;


-- 2. Criação da Tabela 'workspaces'
CREATE TABLE public.workspaces (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    avatar_url text,
    owner_id uuid NOT NULL,
    CONSTRAINT workspaces_pkey PRIMARY KEY (id)
);
COMMENT ON TABLE public.workspaces IS 'Stores workspace information.';

-- 3. Criação da Tabela 'users' (agora com a FK para workspaces)
CREATE TABLE public.users (
    id uuid NOT NULL,
    full_name text,
    avatar_url text,
    email text,
    last_active_workspace_id uuid,
    CONSTRAINT users_pkey PRIMARY KEY (id),
    CONSTRAINT users_email_key UNIQUE (email),
    CONSTRAINT users_id_fkey FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE,
    CONSTRAINT fk_last_active_workspace FOREIGN KEY (last_active_workspace_id) REFERENCES public.workspaces(id) ON DELETE SET NULL
);
COMMENT ON TABLE public.users IS 'Stores public user profile information.';

-- Adiciona a FK do owner_id em workspaces para users, agora que users existe
ALTER TABLE public.workspaces
ADD CONSTRAINT workspaces_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.users(id) ON DELETE CASCADE;


-- 4. Criação da Tabela 'user_workspaces'
CREATE TABLE public.user_workspaces (
    user_id uuid NOT NULL,
    workspace_id uuid NOT NULL,
    CONSTRAINT user_workspaces_pkey PRIMARY KEY (user_id, workspace_id),
    CONSTRAINT user_workspaces_user_id_fkey FOREIGN KEY (user_id) REFERENCES public.users(id) ON DELETE CASCADE,
    CONSTRAINT user_workspaces_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.user_workspaces IS 'Associative table linking users and workspaces.';


-- 5. Criação das outras tabelas
CREATE TABLE public.contacts (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    workspace_id uuid NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    name text NOT NULL,
    avatar_url text,
    email text,
    phone text,
    CONSTRAINT contacts_pkey PRIMARY KEY (id),
    CONSTRAINT contacts_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.contacts IS 'Stores contact information for each workspace.';

CREATE TABLE public.chats (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    workspace_id uuid NOT NULL,
    contact_id uuid NOT NULL,
    agent_id uuid,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    status text NOT NULL DEFAULT 'gerais'::text,
    CONSTRAINT chats_pkey PRIMARY KEY (id),
    CONSTRAINT chats_agent_id_fkey FOREIGN KEY (agent_id) REFERENCES public.users(id) ON DELETE SET NULL,
    CONSTRAINT chats_contact_id_fkey FOREIGN KEY (contact_id) REFERENCES public.contacts(id) ON DELETE CASCADE,
    CONSTRAINT chats_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.chats IS 'Stores chat sessions.';

CREATE TABLE public.messages (
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    content text,
    chat_id uuid NOT NULL,
    sender_id uuid NOT NULL,
    workspace_id uuid NOT NULL,
    CONSTRAINT messages_pkey PRIMARY KEY (id),
    CONSTRAINT messages_chat_id_fkey FOREIGN KEY (chat_id) REFERENCES public.chats(id) ON DELETE CASCADE,
    CONSTRAINT messages_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.messages IS 'Stores individual chat messages.';

CREATE TABLE public.evolution_api_configs (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    workspace_id uuid NOT NULL,
    api_url text,
    api_key text,
    CONSTRAINT evolution_api_configs_pkey PRIMARY KEY (id),
    CONSTRAINT evolution_api_configs_workspace_id_key UNIQUE (workspace_id),
    CONSTRAINT evolution_api_configs_workspace_id_fkey FOREIGN KEY (workspace_id) REFERENCES public.workspaces(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.evolution_api_configs IS 'Stores Evolution API configurations for each workspace.';

CREATE TABLE public.evolution_api_instances (
    id uuid NOT NULL DEFAULT gen_random_uuid(),
    config_id uuid NOT NULL,
    name text NOT NULL,
    type text NOT NULL,
    CONSTRAINT evolution_api_instances_pkey PRIMARY KEY (id),
    CONSTRAINT evolution_api_instances_config_id_fkey FOREIGN KEY (config_id) REFERENCES public.evolution_api_configs(id) ON DELETE CASCADE
);
COMMENT ON TABLE public.evolution_api_instances IS 'Stores individual Evolution API instances.';


-- 6. Funções e Triggers
-- Função para criar um perfil de usuário público quando um novo usuário se registra
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.users (id, full_name, email, avatar_url)
  VALUES (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.email,
    new.raw_user_meta_data->>'avatar_url'
  );
  RETURN new;
END;
$$;
-- Trigger que chama a função acima
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Função para definir o proprietário de um novo workspace
CREATE OR REPLACE FUNCTION public.set_workspace_owner()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  new.owner_id := auth.uid();
  RETURN new;
END;
$$;
-- Trigger para definir o proprietário
CREATE TRIGGER set_workspace_owner_trigger
  BEFORE INSERT ON public.workspaces
  FOR EACH ROW EXECUTE PROCEDURE public.set_workspace_owner();

-- Função para adicionar o criador como membro do workspace
CREATE OR REPLACE FUNCTION public.add_creator_to_workspace()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.user_workspaces (user_id, workspace_id)
  VALUES (new.owner_id, new.id);
  RETURN new;
END;
$$;
-- Trigger para adicionar o membro
CREATE TRIGGER add_creator_to_workspace_trigger
  AFTER INSERT ON public.workspaces
  FOR EACH ROW EXECUTE PROCEDURE public.add_creator_to_workspace();


-- 7. Políticas de Segurança (RLS)
-- Habilita RLS para todas as tabelas
ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.workspaces ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_workspaces ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chats ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_api_configs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.evolution_api_instances ENABLE ROW LEVEL SECURITY;

-- Remove políticas antigas para garantir um estado limpo
DROP POLICY IF EXISTS "Users can read their own data" ON public.users;
DROP POLICY IF EXISTS "Users can update their own data" ON public.users;
DROP POLICY IF EXISTS "Authenticated users can create workspaces" ON public.workspaces;
DROP POLICY IF EXISTS "Users can view workspaces they are a member of" ON public.workspaces;
DROP POLICY IF EXISTS "Owners can update their own workspaces" ON public.workspaces;
DROP POLICY IF EXISTS "Owners can delete their own workspaces" ON public.workspaces;
DROP POLICY IF EXISTS "Users can view their own workspace memberships" ON public.user_workspaces;
DROP POLICY IF EXISTS "Users can be added by workspace owner" ON public.user_workspaces;
DROP POLICY IF EXISTS "Users can leave workspaces" ON public.user_workspaces;
DROP POLICY IF EXISTS "Users can access contacts in their workspaces" ON public.contacts;
DROP POLICY IF EXISTS "Users can access chats in their workspaces" ON public.chats;
DROP POLICY IF EXISTS "Users can access messages in their workspaces" ON public.messages;
DROP POLICY IF EXISTS "Users can access Evolution API configs in their workspaces" ON public.evolution_api_configs;
DROP POLICY IF EXISTS "Users can access Evolution API instances in their workspaces" ON public.evolution_api_instances;


-- Políticas para 'users'
CREATE POLICY "Users can read their own data" ON public.users FOR SELECT USING (auth.uid() = id);
CREATE POLICY "Users can update their own data" ON public.users FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- Políticas para 'workspaces'
CREATE POLICY "Authenticated users can create workspaces" ON public.workspaces FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Users can view workspaces they are a member of" ON public.workspaces FOR SELECT TO authenticated USING (
  id IN (SELECT workspace_id FROM public.user_workspaces WHERE user_id = auth.uid())
);
CREATE POLICY "Owners can update their own workspaces" ON public.workspaces FOR UPDATE TO authenticated USING (owner_id = auth.uid()) WITH CHECK (owner_id = auth.uid());
CREATE POLICY "Owners can delete their own workspaces" ON public.workspaces FOR DELETE TO authenticated USING (owner_id = auth.uid());

-- Políticas para 'user_workspaces'
CREATE POLICY "Users can view their own workspace memberships" ON public.user_workspaces FOR SELECT TO authenticated USING (user_id = auth.uid());
CREATE POLICY "Users can be added by workspace owner" ON public.user_workspaces FOR INSERT TO authenticated WITH CHECK (
  workspace_id IN (SELECT id FROM public.workspaces WHERE owner_id = auth.uid())
);
CREATE POLICY "Users can leave workspaces" ON public.user_workspaces FOR DELETE TO authenticated USING (user_id = auth.uid());


-- Políticas para as tabelas restantes (baseadas na associação ao workspace)
CREATE POLICY "Users can access contacts in their workspaces" ON public.contacts FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.user_workspaces WHERE user_id = auth.uid())
);
CREATE POLICY "Users can access chats in their workspaces" ON public.chats FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.user_workspaces WHERE user_id = auth.uid())
);
CREATE POLICY "Users can access messages in their workspaces" ON public.messages FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.user_workspaces WHERE user_id = auth.uid())
);
CREATE POLICY "Users can access Evolution API configs in their workspaces" ON public.evolution_api_configs FOR ALL USING (
  workspace_id IN (SELECT workspace_id FROM public.user_workspaces WHERE user_id = auth.uid())
);
CREATE POLICY "Users can access Evolution API instances in their workspaces" ON public.evolution_api_instances FOR ALL USING (
  config_id IN (SELECT id FROM public.evolution_api_configs WHERE workspace_id IN (
    SELECT workspace_id FROM public.user_workspaces WHERE user_id = auth.uid()
  ))
);
